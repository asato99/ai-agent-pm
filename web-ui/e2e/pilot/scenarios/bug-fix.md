# パイロットシナリオ: bug-fix

## 概要

既存のバグを含むコードをAIエージェントがレビュー・修正するシナリオ。
hello-worldより複雑で実践的なケースとして、バグ発見能力と修正能力を検証する。

## 目的

- AIエージェントによるバグ発見能力の検証
- 複数バグの同時修正能力の検証
- コードレビュー→問題特定→修正→検証のフロー検証

## 対象コード

### text_stats.py

テキストの統計情報（単語数、文字数、行数）を計算するモジュール。

**含まれるバグ:**

| # | バグ | 問題のあるコード | 期待する動作 |
|---|------|-----------------|-------------|
| 1 | 連続スペースで空文字がカウントされる | `text.split(" ")` | 連続スペースを正しく処理 |
| 2 | 最後の行がカウントされない | `text.count("\n")` | 全行を正しくカウント |

**現在の動作（バグあり）:**
```python
>>> analyze_text("Hello  World")  # スペース2つ
{'words': 3, ...}  # 期待: 2

>>> analyze_text("Line1\nLine2\nLine3")
{'lines': 2, ...}  # 期待: 3
```

## エージェント構成

hello-worldシナリオと同一構成：
- Owner（人間役 = Playwright）
- Manager（AI）: タスク分解・割当
- Worker-Dev（AI）: コード修正
- Worker-Review（AI）: 動作検証

## テスト実行フロー

### Phase 1: 準備

1. 作業ディレクトリをクリーンアップ
2. `text_stats.py`（バグ入り）を作業ディレクトリに配置
3. パイロット用エージェント・プロジェクトを作成

### Phase 2: 要件伝達

Ownerが以下のメッセージをManagerに送信：

```
text_stats.py にいくつかのバグがあるようです。
コードをレビューして問題を特定し、修正してください。
修正後は動作確認も行ってください。
```

### Phase 3: 開発進行（AIエージェントが実行）

期待される流れ：

1. **Manager** がタスクを作成：
   - コードレビュー・バグ特定
   - バグ修正
   - 動作確認

2. **Worker-Dev** がコードをレビュー：
   - バグ1: `split(" ")` の問題を発見
   - バグ2: `count("\n")` の問題を発見
   - 修正を実施

3. **Worker-Review** が修正を検証：
   - 連続スペースのケースをテスト
   - 行数カウントのケースをテスト
   - 修正完了を確認

### Phase 4: 検証

テストスクリプトが成功基準を検証：

1. 全タスクが `done` であることを確認
2. `text_stats.py` が修正されていることを確認
3. 検証テストを実行：
   - `analyze_text("Hello  World")` → words: 2
   - `analyze_text("Line1\nLine2\nLine3")` → lines: 3
   - `analyze_text("")` → words: 0, lines: 0

## 成功基準

| # | 基準 | 検証方法 |
|---|------|----------|
| 1 | Manager がタスクを作成する | タスク数を確認 |
| 2 | バグ1（連続スペース）が修正される | テスト実行 |
| 3 | バグ2（行数カウント）が修正される | テスト実行 |
| 4 | 空文字列を正しく処理する | テスト実行 |
| 5 | 全タスクが `done` になる | ステータス確認 |

## 所要時間（想定）

| フェーズ | 時間 |
|----------|------|
| 準備 | 30秒 |
| 要件伝達 | 30秒 |
| 開発進行 | 10〜20分 |
| 検証 | 1分 |
| **合計** | **約15〜25分** |

## 観察ポイント

- バグ発見のアプローチ（実行して確認 vs コード読解）
- 両方のバグを発見できるか
- 修正方法の適切さ
- エッジケース（空文字列）への対応

## 期待される修正

```python
def analyze_text(text):
    words = text.split()  # 修正1: split()で連続空白を正しく処理
    word_count = len(words)
    char_count = len(text)

    # 修正2: 空でなければ行数 = 改行数 + 1
    if text:
        line_count = text.count("\n") + 1
    else:
        line_count = 0

    return {
        "words": word_count,
        "characters": char_count,
        "lines": line_count
    }
```
