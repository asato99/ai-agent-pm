# パイロットテスト設計

## 概要

パイロットテストは、AI Agent PMシステムを使用して**実際のアプリケーション開発を行い**、エージェント間の協調動作やプロンプト設定の効果を検証する運用試験である。

通常のE2Eテストが機能単位の動作を検証するのに対し、パイロットテストは**実際のAIエージェントが実際のLLMを使用して実際の開発作業を行う**ことで、システム全体の有効性を検証する。

## 通常のE2Eテストとの違い

| 項目 | E2Eテスト | パイロットテスト |
|------|----------|----------------|
| エージェント | モック（MSW） | **実際のAI（LLM呼び出し）** |
| タスク実行 | 状態変更のみ | **実際のコード生成・ファイル作成** |
| 所要時間 | 数秒〜数分 | 数十分〜数時間 |
| 成果物 | なし | **実際に動作するコード** |
| 目的 | 機能の動作確認 | **運用の有効性検証** |
| コスト | 低い | LLM API費用が発生 |

## 検証項目

### 1. エージェント関係性

- Manager → Worker への指示は明確に伝わるか
- Worker → Manager への報告は適切か
- 複数Worker間の依存関係は正しく解決されるか
- 階層構造（Owner → Manager → Worker）は機能するか

### 2. プロンプト設定の効果

- システムプロンプトの内容が行動にどう反映されるか
- ロール定義の違いが出力品質にどう影響するか
- 制約条件は遵守されるか

### 3. 開発ワークフロー

- タスク分解は適切な粒度で行われるか
- 進捗報告のタイミングと内容は適切か
- ブロッカー発生時に適切な対応がされるか
- 成果物の品質は要件を満たすか

## アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                      パイロットテスト環境                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  テストランナー (Playwright)                          │   │
│  │  - Owner役としてUI操作                               │   │
│  │  - 状態の観察・記録                                  │   │
│  │  - 成功基準の検証                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│                           ▼                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  AI Agent PM (実システム)                            │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐       │   │
│  │  │  Web UI   │  │ REST API  │  │ Database  │       │   │
│  │  └───────────┘  └───────────┘  └───────────┘       │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│                           ▼                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  AIエージェント (実際のLLM)                          │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐       │   │
│  │  │  Manager  │  │ Worker-1  │  │ Worker-2  │       │   │
│  │  │ (Claude)  │  │ (Claude)  │  │ (Claude)  │       │   │
│  │  └───────────┘  └───────────┘  └───────────┘       │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│                           ▼                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  作業ディレクトリ                                    │   │
│  │  - 実際に生成されたコード                            │   │
│  │  - 実際に動作する成果物                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 実行フロー

### 1. 準備

```
1. パイロット用のプロジェクトを作成
2. エージェントを登録（プロンプト設定含む）
3. 作業ディレクトリを準備
```

### 2. 開発開始

```
1. Owner（テストスクリプト）がManagerにチャットで要件を伝える
2. Managerが要件を理解し、タスクを作成・割り当て
3. Workerがタスクを受け取り、実装を開始
```

### 3. 開発進行

```
1. 各Workerが実際にコードを生成
2. 生成したコードを作業ディレクトリに保存
3. 進捗をコンテキストに記録
4. 依存タスクの完了を待って次のWorkerが作業開始
```

### 4. 完了・検証

```
1. 全タスクが完了
2. 成果物が作業ディレクトリに存在することを確認
3. 成果物が実際に動作することを確認
```

## テストランナーの役割

テストランナー（Playwright）は以下を担当する：

1. **Owner役としてのUI操作**
   - ログイン
   - Managerへのチャット送信（要件伝達）
   - タスクボードの確認

2. **状態の観察・待機**
   - タスクのステータス変化を監視
   - エージェントの応答を待機
   - タイムアウト管理

3. **成功基準の検証**
   - 成果物ファイルの存在確認
   - 成果物の動作確認
   - タスク完了状態の確認

## ディレクトリ構成

```
web-ui/
├── e2e/
│   ├── tests/                       # 通常のE2Eテスト（モック使用）
│   ├── integration/                 # 統合テスト（実サーバー使用）
│   └── pilot/                       # パイロットテスト（実LLM使用）
│       ├── playwright.pilot.config.ts  # Playwright設定
│       ├── scenarios/               # シナリオ定義
│       │   └── hello-world.md
│       ├── setup/                   # シードデータ
│       │   └── seed-pilot-hello.sql
│       ├── tests/                   # テストコード
│       │   └── hello-world.spec.ts
│       ├── utils/                   # ヘルパー関数
│       │   ├── pilot-helpers.ts
│       │   └── progress-monitor.ts
│       ├── workspaces/              # 作業ディレクトリ（成果物）
│       │   └── hello-world/
│       └── run-pilot-hello.sh       # 実行スクリプト
```

## 実行方法

```bash
# hello-worldシナリオの実行（全自動）
cd web-ui
./e2e/pilot/run-pilot-hello.sh

# 観察モード（ブラウザ表示、スローモーション）
PILOT_SLOW_MO=2000 ./e2e/pilot/run-pilot-hello.sh

# Playwrightテストのみ実行（サーバーが既に起動している場合）
PILOT_WEB_URL="http://localhost:5173" \
PILOT_WITH_COORDINATOR="true" \
npx playwright test --config=e2e/pilot/playwright.pilot.config.ts hello-world.spec.ts
```

## 注意事項

- **実際のLLM API呼び出しが発生する**（費用がかかる）
- **実行時間が長い**（数十分〜数時間）
- **ネットワーク接続が必要**
- **APIキーの設定が必要**

## タイムアウトとスタック検出

### 基本方針

パイロットテストは実運用を想定するため、タイムアウトは長めに設定する。
一方で、スタックやループによる無限待機を避けるため、複数の検出・回避策を講じる。

### タイムアウト設定

| レベル | 対象 | 推奨値 | 説明 |
|--------|------|--------|------|
| シナリオ全体 | テスト全体の実行時間 | 30〜60分 | 全フェーズ完了までの最大時間 |
| フェーズ | 各フェーズの実行時間 | 10〜15分 | 準備/要件伝達/開発進行/検証 |
| タスク | 単一タスクの完了待ち | 5〜10分 | 1つのタスクが完了するまで |
| API応答 | LLM API呼び出し | 2〜3分 | 単一のAPI呼び出し |

### スタック・ループ検出

#### 1. 進捗監視

一定時間内に進捗がない場合をスタックとみなす：

```
検出条件:
- タスクのステータスが N 分間変化しない
- コンテキストが N 分間追加されない
- チャットメッセージが N 分間発生しない

対応:
- 警告をログに記録
- 継続判断のためのチェックポイントを設ける
```

#### 2. ループ検出

同じパターンの繰り返しを検出：

```
検出条件:
- 同一内容のメッセージが短時間に複数回発生
- タスクのステータスが同じ値を往復
- 同一エラーが繰り返し発生

対応:
- 即座にテストを中断
- ループ発生箇所をログに記録
```

#### 3. リソース監視

異常なリソース消費を検出：

```
検出条件:
- LLMトークン使用量が想定の N 倍を超過
- API呼び出し回数が想定の N 倍を超過
- メモリ使用量の異常増加

対応:
- 警告を発して継続判断
- 閾値超過で強制中断
```

### 切り上げ判断の基準

タイムアウトに達した際の判断フロー：

```
1. 進捗があるか？
   ├─ YES → タイムアウトを延長して継続
   └─ NO  → 2へ

2. 最後の活動から何分経過？
   ├─ 5分未満 → もう少し待機
   └─ 5分以上 → 3へ

3. 回復可能なエラー状態か？
   ├─ YES → リトライを試みる
   └─ NO  → テストを中断

4. 部分的な成功を記録
   - 完了したタスク
   - 生成された成果物
   - 発生した問題
```

### 安全な中断

テストを中断する際は以下を実施：

1. **状態の保存**: 現在の状態をスナップショットとして保存
2. **リソースの解放**: 実行中のプロセスを適切に終了
3. **ログの出力**: 中断理由と状態を詳細にログ出力
4. **成果物の保持**: 途中まで生成された成果物は削除しない

### 実装例

```typescript
// パイロットテストの待機処理
async function waitForTaskCompletion(taskId: string, options: {
  timeout: number        // 最大待機時間（ミリ秒）
  progressInterval: number  // 進捗チェック間隔（ミリ秒）
  staleThreshold: number    // スタック判定閾値（ミリ秒）
}) {
  const startTime = Date.now()
  let lastProgress = Date.now()
  let lastStatus = null

  while (Date.now() - startTime < options.timeout) {
    const task = await getTask(taskId)

    // 完了チェック
    if (task.status === 'done') {
      return { success: true, task }
    }

    // 進捗チェック
    if (task.status !== lastStatus || task.updatedAt !== lastUpdatedAt) {
      lastProgress = Date.now()
      lastStatus = task.status
    }

    // スタック検出
    if (Date.now() - lastProgress > options.staleThreshold) {
      console.warn(`Task ${taskId} appears stale (no progress for ${options.staleThreshold}ms)`)
      // 継続判断のロジック
    }

    await sleep(options.progressInterval)
  }

  return { success: false, reason: 'timeout', task: await getTask(taskId) }
}
```

## 評価指標

### 定量指標

| 指標 | 説明 |
|------|------|
| タスク完了率 | 作成されたタスクのうち完了した割合 |
| 所要時間 | 要件伝達から全タスク完了までの時間 |
| LLMトークン使用量 | 消費したトークン数 |
| エラー発生率 | 失敗したタスクの割合 |

### 定性指標

| 指標 | 説明 |
|------|------|
| タスク分解の質 | 適切な粒度と依存関係 |
| 成果物の品質 | コードの正確さ、可読性 |
| コミュニケーションの質 | 報告・相談の適切さ |
