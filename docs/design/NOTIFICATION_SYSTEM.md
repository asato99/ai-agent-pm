# 通知システム設計

タスク実行中のエージェントに対する割り込み・通知の仕組み。

## 概要

### 課題

- エージェントがタスク実行中に、ユーザーからのキャンセルやメッセージを受け取る手段がない
- `get_next_action` のポーリング間隔に依存するとリアルタイム性が低い

### 解決策

全MCPツールのレスポンスにミドルウェアで通知情報を付加し、エージェントが任意のツール呼び出し時に通知の存在を検知できるようにする。

**重要**: 中断通知（interrupt）の場合は、ツールの戻り値を完全に通知メッセージに差し替える。これによりエージェントは通知に対応せざるを得なくなる。

---

## アーキテクチャ

```
┌─────────────────────────────────────────────────────────┐
│                    MCPServer                            │
│                                                         │
│  handleToolsCall()                                      │
│       │                                                 │
│       ├── executeTool() → result                        │
│       │                                                 │
│       ├── checkNotifications(caller) ← ミドルウェア     │
│       │       │                                         │
│       │       ├── interrupt通知あり → レスポンス差替え  │
│       │       ├── 通常通知あり     → フィールド追加     │
│       │       └── 通知なし         → フィールド追加     │
│       │                                                 │
│       └── return { result/notification }                │
└─────────────────────────────────────────────────────────┘
```

---

## レスポンス構造

### 通常時: notification フィールド

全MCPツールのレスポンスに固定フィールドとして追加。

**通知なし:**
```json
{
  "result": { ... },
  "notification": "通知はありません"
}
```

**通知あり（通常）:**
```json
{
  "result": { ... },
  "notification": "【重要】通知があります。get_notifications を呼び出して確認してください。"
}
```

### 中断通知時: レスポンス差替え

**interrupt通知がある場合**、ツールの戻り値を完全に通知メッセージに差し替える:

```json
{
  "content": [
    {
      "type": "text",
      "text": "通知があります。\n\n1. get_notifications() を呼び出して詳細を確認してください\n2. 通知の指示に従ってください"
    }
  ]
}
```

> **設計根拠**: 単にフィールドを追加するだけではエージェントが気づかない場合がある。レスポンス全体を差し替えることで、エージェントは通知に対応せざるを得なくなる。

### 設計原則

- **固定フィールド**: `notification` は常に存在（通常時）
- **自然言語**: エージェントが理解しやすい形式
- **詳細分離**: 通知の存在シグナルのみ、詳細は別ツールで取得
- **強制対応**: interrupt通知はレスポンス差替えで確実に伝達

---

## get_notifications ツール

エージェントが通知の詳細を取得するためのツール。

### リクエスト

```json
{
  "session_token": "xxx"
}
```

### レスポンス

```json
{
  "notifications": [
    {
      "type": "...",
      "action": "...",
      "message": "...",
      "instruction": "..."
    }
  ]
}
```

### 通知タイプ（案）

| type | action | 説明 |
|------|--------|------|
| interrupt | cancel | タスクキャンセル要求 |
| interrupt | pause | 一時停止要求 |
| message | - | ユーザーからのメッセージ |

> **TODO**: 具体的な type/action の種類と instruction の文言を確定する

---

## エージェント側の処理フロー

### 通常通知の場合

```
1. 任意のMCPツールを呼び出す
2. レスポンスの notification フィールドを確認
3. "通知があります" の場合:
   a. get_notifications を呼び出す
   b. 通知内容に応じて対応（キャンセル、メッセージ確認など）
4. 通常の処理を継続
```

### 中断通知（interrupt）の場合

```
1. 任意のMCPツールを呼び出す
2. レスポンスが通知メッセージに差し替えられている
   （本来のツール結果は返されない）
3. get_notifications を呼び出す
4. 通知の指示に従って処理を中断
5. report_completed(result="blocked") を呼び出す
```

> **注意**: 中断通知がある場合、エージェントは本来呼び出したツールの結果を受け取れない。これは意図的な設計であり、エージェントに中断を強制するためである。

---

## 実装箇所

### MCPServer（ミドルウェア）

- `handleToolsCall()` にて全レスポンスに notification を付加
- `getNotificationMessage(caller)` で通知有無を判定

### 新規ツール

- `get_notifications`: 通知詳細取得

### データモデル（検討中）

通知の格納方法:
- 新規テーブル `notifications`
- または既存の仕組み（chat, event など）を活用

---

## ユースケース

- [UC010: タスク実行中にステータス変更による割り込み](../usecase/UC010_TaskInterruptByStatusChange.md)

---

## 実装状況

### 完了

- [x] 通知の対象単位: `agentId + projectId` の組み合わせ
- [x] 通知の格納: `notifications` テーブル
- [x] 既読管理: `get_notifications` 呼び出し時に自動で既読化
- [x] 複数通知の処理: 全件返却、新しい順にソート
- [x] 通知タイプ: `interrupt`（中断）を実装
- [x] ミドルウェアによる通知付加
- [x] 中断通知のレスポンス差替え方式

### 未確定事項

- [ ] 通知タイプの拡張（message等）
- [ ] 通知の有効期限・クリーンアップ

---

## 参照

- MCPServer実装: `Sources/MCPServer/MCPServer.swift`
- handleToolsCall: 264行目付近
- ミドルウェア（通知チェック）: 289行目付近
- 統合テスト: `web-ui/e2e/integration/task-interrupt.spec.ts`
