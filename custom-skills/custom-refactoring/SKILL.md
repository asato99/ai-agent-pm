---
name: custom-refactoring
description: TDDのRefactorフェーズ、およびコード品質改善の作業時に使用する。Greenの後のリファクタリング判断、コードの臭い検出、安全なリファクタリング手順を提供する。custom-tddスキルのRefactorフェーズから参照される。
---

# Custom Refactoring

Martin Fowlerの「Refactoring」に基づくリファクタリングの基本思想。

## リファクタリングの定義

> ソフトウェアの外部的振る舞いを保ったまま、内部構造を改善していく作業。— Martin Fowler

リファクタリングは「きれいにする」ことではない。**コードの理解しやすさと変更しやすさを改善する**こと。

## 2つの帽子

Fowlerの「2つの帽子」メタファー:

- **機能追加の帽子**: 新しい振る舞いを追加する。既存コードの構造は変えない。
- **リファクタリングの帽子**: コードの構造を改善する。振る舞いは変えない。

**同時に2つの帽子をかぶらない。** どちらの帽子をかぶっているか常に意識し、頻繁に帽子を切り替える。

## なぜリファクタリングするか

- **理解しやすくするため**: コードは人間が読むために書く。コンピュータのためだけなら動けば良い。
- **変更しやすくするため**: 次の機能追加やバグ修正が楽になる。
- **バグを見つけやすくするため**: コードを理解すればバグが見える。
- **速く開発するため**: 設計が良ければ機能追加が速い。リファクタリングは投資。

## いつリファクタリングするか

### TDDサイクル内（必須）

Greenの後、**毎回**リファクタリングの必要性を判断する:

1. コードの臭いがあるか？ → あればリファクタリング
2. 直前のGreen実装に重複や不明瞭さがあるか？ → あればリファクタリング
3. テストコード自体に重複がないか？ → あればテストもリファクタリング

「特にない」と判断した場合のみ次のRedへ進む。**判断をスキップしてはならない。**

### 三度目の法則（Rule of Three）

> 似たことを三度目にやったら、リファクタリングする。— Don Roberts（Fowlerが引用）

一度目はそのまま書く。二度目は重複に気づくがそのまま書く。三度目にリファクタリングする。

### 準備的リファクタリング

機能追加の前に、追加しやすい構造に整える:

> 変更を加える前に、その変更が加えやすいようにリファクタリングする。

### 理解のためのリファクタリング

コードを読んで理解した結果を、コードそのものに反映する。理解をコメントに書くのではなく、コードの構造と命名に埋め込む。

## コードの臭い（Code Smells）

Fowlerが分類したリファクタリングが必要なサイン:

### 基本の臭い

| 臭い | 症状 |
|-----|------|
| **重複コード (Duplicated Code)** | 同じコード構造が複数箇所にある |
| **長いメソッド (Long Method)** | メソッドが長すぎる。短いメソッドの方が理解しやすい |
| **大きなクラス (Large Class)** | 1つのクラスがやりすぎている |
| **長いパラメータリスト (Long Parameter List)** | 引数が多すぎる |
| **変更の分散 (Divergent Change)** | 1つの変更理由で複数箇所を変える必要がある |
| **変更の偏り (Shotgun Surgery)** | 1つの変更が多くのクラスに波及する |

### 結合の臭い

| 臭い | 症状 |
|-----|------|
| **Feature Envy** | メソッドが自分のクラスより他クラスのデータを多く使う |
| **データの群れ (Data Clumps)** | 同じデータの組が一緒に出現する |
| **プリミティブ執着 (Primitive Obsession)** | プリミティブ型で概念を表現している |
| **不適切な関係 (Inappropriate Intimacy)** | クラス同士が互いの内部を覗きすぎる |

### 不要なものの臭い

| 臭い | 症状 |
|-----|------|
| **推測的な汎用性 (Speculative Generality)** | 「いつか使うかも」で作った抽象化 |
| **死んだコード (Dead Code)** | 使われていないコード |
| **コメント (Comments)** | コードが不明瞭なことのサイン。コードを改善すればコメントは不要になる |

## 基本的なリファクタリング手法

### メソッドの抽出 (Extract Method)

最も頻繁に使うリファクタリング。コードの断片に名前をつける。

```swift
// Before
func printDetails() {
    // バナー出力
    print("***")
    print("Customer: \(name)")
    print("***")
    // 明細出力
    for item in items {
        print("  \(item.name): \(item.price)")
    }
}

// After
func printDetails() {
    printBanner()
    printItems()
}
```

**判断基準**: 「何をしているか」にコメントを書きたくなったら、そのブロックをメソッドとして抽出する。メソッド名がコメントの代わりになる。

### 変数のインライン化 (Inline Variable)

変数が式と同程度に明確な場合、変数を除去する。

### 関数のインライン化 (Inline Function)

関数本体が関数名と同程度に明確な場合、呼び出し元に展開する。不要な間接化を排除。

### 変数の抽出 (Extract Variable)

複雑な式に名前をつけて分解する。

```swift
// Before
if order.quantity * order.price - max(0, order.quantity - 500) * order.price * 0.05 > 1000 { ... }

// After
let basePrice = order.quantity * order.price
let discount = max(0, order.quantity - 500) * order.price * 0.05
let finalPrice = basePrice - discount
if finalPrice > 1000 { ... }
```

### パラメータオブジェクトの導入 (Introduce Parameter Object)

一緒に渡されるデータの群れをオブジェクトにまとめる。

### ガード節による条件の置き換え (Replace Nested Conditional with Guard Clauses)

ネストした条件を早期リターンに変換する。

## リファクタリングの進め方

### 小さなステップで

> リファクタリングは小さなステップで行う。間違えてもすぐに見つけられるように。— Fowler

1. テストがGreenであることを確認
2. 1つの小さな変更を行う
3. テスト実行 → Green → 次へ / Red → 取り消して再考
4. 繰り返す

### リファクタリングしてはいけないとき

- テストがRedの状態
- 振る舞いの変更を伴う（帽子が違う）
- 期限に追われて「後で」→ **小さくやれば時間はかからない。「後で」は来ない**

## チェックリスト

リファクタリング完了時:

- [ ] テストがすべてGreen
- [ ] 外部の振る舞いが変わっていない
- [ ] コードの意図が以前より明確になった
- [ ] 重複が減った
- [ ] 各メソッド・クラスの責務が明確
