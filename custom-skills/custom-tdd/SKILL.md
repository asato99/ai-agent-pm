---
name: custom-tdd
description: 機能実装やバグ修正の前に使用する。TDDワークフロー、テスト設計の思考法、アーキテクチャ層別テストパターンを提供する。機能実装、バグ修正、リファクタリング、振る舞い変更の作業時に自動適用する。
---

# Custom TDD

## TDDの本質

TDDは**設計プロセス**である。テストを先に書くことでAPIの使い方を先に考え、クリーンな設計と構造を導く。

品質管理（バグ検出・回帰防止）は副次的な効果であり、主目的ではない。主目的は**実装レベルのクリーンな設計を生み出すこと**。

対比: UIテストは品質管理のためのもの。ユーザー体験の保証と、盲点になりやすい微妙な挙動の検出に注力する。

## 鉄則

```
失敗するテストなしに製品コードを書いてはならない
```

テストより先にコードを書いた場合、削除してやり直す。例外なし。

## Red-Green-Refactor

### RED - 失敗するテストを1つ書く

1. あるべき振る舞いを示すテストを1つだけ書く
2. テスト実行し、**正しい理由で失敗する**ことを確認（タイポではなく機能が未実装）
3. テストが即座にパスした場合 → 既存の振る舞いをテストしている。テストを修正する。

要件:
- 1テスト = 1つの振る舞い
- テスト名は振る舞いを明確に記述
- 実コードをテストする（モックは不可避な場合のみ）

### GREEN - 最小限のコード

1. テストをパスさせる最小限のコードを書く
2. テスト実行し、パスを確認
3. 他のテストもすべてパスすることを確認

テスト要求以上の機能追加・リファクタリング・「改善」をしない。

### REFACTOR - 整理

Greenの後に**毎回**リファクタリングの必要性を判断する。判断をスキップしてはならない。

詳細な判断基準・手法・コードの臭いについては **custom-refactoring** スキルを参照。

### 繰り返し

次の振る舞いに対する失敗テストへ進む。

## テスト設計: 何をテストするか

テストを書く前に3つの問いに答える:

### 1. 仕様は何か？

情報源: 設計ドキュメント、関数シグネチャ、ドメインルール、ユーザーストーリー

仕様が「1キーのみ、キー進行なし」→ 正確に1キーが生成されることをテスト。
仕様が「ソート済みリストを返す」→ ソート順をテスト（非空チェックだけでは不十分）。

### 2. どの性質が成り立つべきか？

- **仕様のコア**: そのメソッドの存在意義を表すプロパティを検証する
- **境界値**: 0, 1, 最大値, 空, nil
- **状態遷移**: 操作前後の状態変化
- **エラー条件**: 不正入力、失敗パス

### 3. どの粒度でテストするか？

| テスト対象 | 適用場面 |
|-----------|---------|
| 単一メソッド | 純粋なロジック、計算、変換 |
| クラスの振る舞い | 状態管理、ライフサイクル |
| ユースケースフロー | 複数コンポーネントの協調 |
| 統合 | 外部システムとの連携 |

## ファクトリ・変換メソッドのテスト

オブジェクトを生成・変換するメソッド（ファクトリ、`toX()`, `from()`）はサイレントバグの温床。

**ルール: 仕様のコアとなるプロパティをアサートする。**

テストは設計意図を表現するもの。機械的に全プロパティを列挙するのではなく、「このメソッドが保証すべき契約は何か」を考えてアサートを選ぶ。

```swift
// BAD - 非nilチェックのみ（何も保証しない）
let result = part.toDemoSettings()
XCTAssertNotNil(result)

// GOOD - 仕様のコアを検証（このメソッドの存在意義が明確になる）
let result = part.toDemoSettings()
XCTAssertEqual(result.keyCount, 0)  // 仕様: "キー進行なし"
XCTAssertEqual(result.pattern, .ascendingOnly)
```

テストが設計の意図を語る。読めば「このメソッドは何のために存在するか」がわかる。

## バグ修正ワークフロー

1. **RED**: バグを再現するテストを書く（製品コードは触らない）
2. **GREEN**: 製品コードのみ修正する（テストコードは触らない）
3. **REFACTOR**: 整理、全テストGreen

再現テストが回帰を永久に防ぐ。

## よくある合理化

| 言い訳 | 現実 |
|-------|------|
| 「テストするまでもない」 | 簡単なコードも壊れる。テストは30秒で書ける。 |
| 「後でテストする」 | 後から書いたテストは即座にパスする。何も証明しない。 |
| 「まず調査が必要」 | 調査は良い。だが調査コードは捨てて、TDDで最初から書く。 |
| 「テストが難しい」 | テストしづらい = 使いづらい。設計を簡素化する。 |
| 「参考用に残す」 | 結局それを流用する。後からテストと同じ。削除は削除。 |

## 危険信号 - 止まってやり直す

- テストより先にコードを書いた
- テストが即座にパスした（新しいものをテストしていない）
- テストがなぜ失敗すべきか説明できない
- 「今回だけ」と合理化している
- ファクトリ・変換メソッドのテストが非nilチェックのみ

## 完了チェックリスト

作業完了前に確認:

- [ ] すべての新規メソッド/関数にテストがある
- [ ] 各テストが実装前に失敗することを確認した
- [ ] 各テストが想定通りの理由で失敗した
- [ ] テストをパスさせる最小限のコードを書いた
- [ ] 全テストがパスしている
- [ ] テストが仕様のコアを表現している（設計意図が読み取れる）
- [ ] エッジケースとエラーパスをカバー済み

## アーキテクチャ層別パターン

詳細は [references/layer-patterns.md](references/layer-patterns.md) を参照:
- Domain層: エンティティ不変条件、値オブジェクト等価性、ビジネスルール
- Application層: ユースケースの協調、依存関係の相互作用
- Infrastructure層: 外部システム統合、データマッピング
- Presentation層: 状態遷移、ユーザーアクション処理
