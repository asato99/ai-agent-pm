---
name: uitest-strategy
description: UIテストの設計・実装・評価・失敗対応の総合フレームワーク。UIテストに関わるすべての作業（新規テスト作成、既存テスト修正、テスト失敗調査、製品コード変更後のカバレッジ確認）で使用する。UIテスト、E2Eテスト、統合テストの作業時に自動適用する。
---

# UIテスト戦略フレームワーク

目的: **作業時間あたりのバグ検出量を最大化する。**
副次目的: 回帰検出用ツールとして機能するテスト資産を構築する。

## 1. 根本原則

1. **テストはバグを検出するためにある** — テストを通すことが目的ではない
2. **テスト操作はユーザー操作のシミュレーション** — テストで効かない操作は製品バグの可能性がある
3. **推測で対応しない** — 切り分けを行ってから対応方針を決める
4. **作業時間の効率を意識する** — バグ検出力が低い作業に時間をかけすぎない

## 2. 作業フェーズ

**1フェーズ = 1目的。** 目的が異なる作業は必ず別フェーズとして分離する。

| 分離すべき組み合わせ | 理由 |
|-------------------|------|
| 製品バグ修正 + テスト修正 | 目的が異なる（製品品質改善 vs テスト品質改善） |
| テスト調査 + 製品コード変更 | 調査中に製品を変えると切り分けが崩れる |
| 新機能テスト追加 + 既存テスト修正 | 注意が分散し品質が低下する |

❌ 「Phase 1: 製品バグ修正 + BPMテスト修正」
✅ 「Phase 1: 製品バグ修正」→「Phase 2: BPMテスト修正」

### テストフェーズ（自律的に実行）

目的: テストスイートを一通り回し、製品の状態を把握する。

1. テストを実行する
2. 失敗したテストを調査・切り分けする（→ セクション4のトリアージ）
3. 切り分け結果に応じて:
   - **テスト側の問題** → 自律的に修正して再実行
   - **製品バグ発見** → 記録し、そのバグに依存するテストはスキップ
   - **手動確認が必要** → ユーザーに操作依頼（セクション4.5）
4. スキップしたもの以外を一通り完了させる

**テストフェーズでの製品コード変更は禁止。**
- アクセシビリティ設定の追加・修正は例外（テスト基盤の整備）
- 調査目的の一時的な変更（ログ追加等）は許可するが、報告前に必ず破棄する

### 報告（一括）

テストフェーズ完了後、発見した製品バグを一覧で報告する。

報告内容:
- **テスト結果サマリ**: パス/失敗/スキップの件数
- **製品バグ一覧**: 各バグについて以下を記載
  - 内容: 何が起きているか
  - 根拠: ログ、スクリーンショット等の切り分け結果
  - 依存テスト: このバグによりスキップしたテスト
- **確認事項**（ある場合）:

| 重要度 | 意味 | 例 |
|-------|------|---|
| 🔴 必須 | 対応方針を決められない | 「free tierでExercise完了不能は仕様か？」 |
| 🟡 推奨 | 対応の質が上がる | 「手動で同じ操作をして再現するか？」 |
| 🟢 参考 | なくても進められる | 「他のスケールタイプでも同様か？」 |

### 修正フェーズ（TDDサイクル）

報告に基づくユーザーの判断を受けてから実施する。

1. 製品バグの修正（Red→Green→Refactor）
2. 修正完了後 → テストフェーズに戻る（スキップ分 + 修正影響範囲）

## 3. テスト設計

### 何をテストするか

バグ検出力が高いテストケースを優先する:

- **ユーザーが実際に辿るフロー** — ハッピーパスと主要なエラーパス
- **状態遷移の境界** — 特に非同期処理完了後の遷移
- **製品コード変更の影響範囲** — 変更した機能に対応するフロー

### テストパラメータの選択

パラメータは**根拠を持って**選択する:

| 考慮事項 | 良い例 | 悪い例 |
|---------|-------|--------|
| 実行時間 | BPM上げて音声を短縮 | タイムアウトを延長して待つ |
| 操作回数 | 必要最小限のキー回数 | デフォルト値をそのまま使う |
| ティア設定 | テスト対象に合った設定 | 制約を避けるためpremium固定 |

**パラメータ選択の原則**:
- テスト実行時間は短い方が作業効率が良い（高BPM、少ないキー回数）
- ただし、短縮がテストの意味を損なわないこと
- 制約回避目的のパラメータ変更（例: premium固定でduration制限回避）は、制約自体のテストを別途行う

### アサーションの厳密性

**各アサーションは1つの具体的な振る舞いを検証する。** OR条件（`A || B`）は仕様の曖昧さの表れであり、最終成果物に残してはならない。

| 状況 | 対応 |
|------|------|
| 仕様が明確 | 1つの期待値を断言する |
| 仕様が不明 | ユーザーに確認してからアサーションを書く |
| 確認がボトルネック | OR条件で仮実装し、報告に🔴で明記（「仕様未確定: resume後の遷移先」） |

仮実装のOR条件は**一時的な措置**であり、仕様確定後に必ず厳密化する。

❌ `XCTAssertTrue(countdownFeedback.exists || practicingFeedback.exists)` — どちらも検証していないのと同じ
✅ `XCTAssertTrue(practicingFeedback.exists)` + `assertGone(countdownFeedback)` — 具体的な1つの振る舞いを断言

### 製品コード変更時のカバレッジ

製品コードを変更したら、**変更の影響範囲を必ずテストする**:

1. 変更した関数/メソッドの直接的な動作
2. その関数を呼び出すフロー（上流）
3. その関数の出力に依存するフロー（下流）
4. **既存アサーションが変更後の振る舞いを正確に検証しているか確認する**
   — 「テストが通る」と「テストが正しい理由で通っている」は別の話

例: `pausePractice()`を変更 → pause→resume→再開フローもテスト対象
例: resume時のカウントダウン除去 → 既存テストのOR条件を厳密化（countdownを不在断言に変更）

## 4. テスト失敗時のトリアージ

### Step 1: 分類

- **A. 要素が見つからない** → Step 2a
- **B. 操作が期待通りに動かない** → Step 2b
- **C. タイムアウト** → Step 2c
- **D. アサーション失敗（値の不一致）** → まず製品バグを疑う

### Step 2a: 要素が見つからない

1. accessibilityIdentifierの設定を確認
2. アクセシビリティツリーの階層を確認（`.accessibilityElement(children:)` 等）
3. 画面遷移完了の待機を確認

→ 製品コード側のアクセシビリティ設定の問題であることが多い

### Step 2b: 操作が期待通りに動かない

**最も判断を誤りやすいポイント。**

1. **まず製品コードで同じ操作を手動で試す**（→ 再現すれば製品バグ）
2. **同じUI部品を操作する成功テストとの差分を分析**（最も有効な切り分け手段）
   - 同じ部品（Stepper, Picker等）で成功しているテストを探す
   - 成功テストとの差分（スクロール有無、要素取得方法、コンテナ構造等）を特定する
   - 差分が原因か検証する
3. **UI実装を確認**: SwiftUIのコンテナ構造が操作に影響していないか

### Step 2c: タイムアウト

1. タイムアウト延長は**調査手段**として使う（最終対応ではない）
2. 延長して通る場合、**なぜ時間がかかるか**の原因を特定
3. 原因に応じた対応:
   - 処理が長い → BPM変更、データ量削減等でパラメータ調整
   - 前段の操作が効いていない → Step 2bに戻る
   - 非同期処理の待ち問題 → wait条件を見直す

### Step 3: テスト側の問題と判断する条件

以下の**すべて**を満たす場合のみ:

- [ ] 手動操作で製品コードが正常動作を確認済み
- [ ] 同じUI部品の他テストが成功している
- [ ] テスト固有の操作手順/タイミングに問題がある根拠がある

**「既知の問題」は存在しない。** あるのは以下の2つだけ:
- **切り分け済み**: 根拠が明文化されている（ログ、スクリーンショット、成功テストとの差分等）
- **未切り分け**: 根拠なく「既知」とされている → 報告一覧に含めて切り分けを行う

コード内のコメント（例: `// Stepper cannot be operated via XCUITest`）も根拠なき主張は信用しない。

### ユーザーへの手動確認依頼

自力調査を尽くし、切り分けが対応方針を決定的に左右する局面で依頼できる。

- 確認操作手順を具体的・簡潔に伝える
- 待ち時間中に他の独立した作業を並行して進める
- 確認結果に応じた対応方針A/Bを事前に準備しておく

## 5. 対応時のチェックリスト

### 製品コード変更時

- [ ] 影響範囲を把握しているか
- [ ] 影響範囲に対するテストカバレッジがあるか（なければ追加）
- [ ] 既存テストが全て通るか
- [ ] 既存アサーションは変更後の振る舞いを正確に検証しているか（「通る」だけでなく「正しい理由で通っている」か）

### テストコード変更時

- [ ] 製品バグの可能性を排除したか
- [ ] テスト実行時間を不必要に増やしていないか
- [ ] バグ検出力が下がっていないか

## 6. アンチパターン

| やりがち | なぜ問題か | 代わりに |
|---------|-----------|---------|
| タイムアウト延長で対応完了 | 根本原因不明、実行時間増加 | 原因特定→パラメータ調整 |
| 「既知の問題」で毎回スルー | 製品バグを見逃し続ける | 切り分け済みなら根拠を示す。未切り分けなら報告一覧に含める |
| 「UIテストの不安定性」で片付ける | 製品バグを見逃す | 切り分けを行う |
| 検証なしの推測で対応 | 作業時間を浪費 | 最小限の検証を先に行う |
| テストスコープを縮小して通す | 本来検出すべきバグを隠す | 製品バグとして報告一覧に含める |
| 製品コード変更後に影響範囲をテストしない | 回帰バグを作る | 影響範囲の既存テスト＋追加テスト実行 |
| OR条件で複数の振る舞いを許容する | どちらの振る舞いも検証していないのと同じ | 仕様を確認し、1つの期待値を断言する。不明なら報告に🔴で明記 |
| 製品変更後「既存テストが通る」で完了とする | テストが弱いだけの可能性がある | 既存アサーションが新しい振る舞いを正確に検証しているか確認する |
| 制約回避のためだけにパラメータ変更 | 制約自体のバグを見逃す | 制約テストを別途作成 |
| 目的の異なる作業を1フェーズにまとめる | 注意分散で品質低下 | 1フェーズ = 1目的に分離 |

## 7. リファレンス

`references/`に実践データに基づく参照資料を蓄積する。トリアージや操作方法で迷った時に参照する。

- **[swiftui-xcuitest-compat.md](references/swiftui-xcuitest-compat.md)**: SwiftUIコンポーネント別のXCUITest操作方法。Stepper、Picker、DisclosureGroupの具体的な操作コードと失敗パターン。
- **[triage-examples.md](references/triage-examples.md)**: トリアージ実例集。BPM Stepper切り分け、Free Tier完了不能バグ発見の過程を記録。

## 8. スクリプト

`scripts/`ディレクトリに有用なスクリプトを蓄積する。テスト作業中に繰り返し必要になる操作はスクリプト化して効率を上げる。

- **test-runner.sh**: テスト実行スクリプト（UI/Unit/All/Critical/Smoke）。プロジェクト側にもコピーあり（`VocalisStudio/scripts/test-runner.sh`）。
- **extract-screenshots.sh**: xcresultからスクリーンショットを自動抽出。Xcode 16対応、最新xcresult自動検出機能付き。
