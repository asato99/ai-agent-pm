---
name: custom-solid
description: 設計判断時に使用する。SOLID原則の適用判断、違反検出、リファクタリング方針の決定を支援する。新規クラス/プロトコル設計、既存コードのリファクタリング、依存関係の見直し作業時に自動適用する。
---

# Custom SOLID

Robert C. Martin「Clean Architecture」第7-11章に基づく設計原則。

## SOLIDの位置づけ

SOLIDは**中間レベル**のソフトウェア構造の原則。関数やデータ構造をどのようにクラスに組み込み、クラス間をどう結合するかを導く。目的は、変更に強く、理解しやすく、多くのシステムで利用できるコンポーネントの基盤を作ること。

custom-tdd（テスト設計）とcustom-refactoring（構造改善）の**判断基準**を提供する。

## SRP: 単一責任の原則

> モジュールはたった1つのアクターに対して責任を負うべき。— Robert C. Martin

「変更する理由が1つ」ではなく「**1つのアクター**に責任を負う」が正確な表現。アクターとは、変更を要求するユーザーやステークホルダーのグループ。

**判断基準**: このクラスを変更する理由が**複数のアクター**から来るか？

**違反兆候**:
- 1つのViewModelがUI表示ロジックとビジネスルール計算の両方を含む
- 1つのクラスが録音制御とピッチ検出の両方を管理する
- 異なる理由（UI変更とドメインルール変更）で同じクラスを編集する

**対処**: クラス分割。共通のアクセスが必要な場合はFacadeパターン（コーディネーターViewModel等）で統合。

## OCP: 開放閉鎖の原則

> ソフトウェアの構成要素は拡張に対して開き、修正に対して閉じていなければならない。— Bertrand Meyer（Martinが引用）

核心: **既存コードを変更せずに新しい振る舞いを追加できる**構造を作る。これはアーキテクチャレベルの関心事であり、すべてのコードに適用するものではない。変更が頻繁に起こる方向を予測し、その方向に対して閉じた設計にする。

**判断基準**: 新しいケースの追加時に既存コードのswitch/ifを編集するか？

**違反兆候**:
- enum caseを追加するたびに複数ファイルのswitch文を修正
- 新しい再生方式を追加するために既存のScalePlayer実装を変更
- 条件分岐が増え続けるメソッド

**対処**: Protocol + 具象実装（Strategy パターン）。新しい振る舞いは新しいProtocol準拠型として追加する。

## LSP: リスコフの置換原則

> 派生型はその基本型と置換可能でなければならない。— Barbara Liskov

核心: Protocol準拠型は、呼び出し側が**具象型を知らなくても正しく動く**。事前条件を強化したり、事後条件を緩和したりしてはならない。LSP違反はOCP違反を引き起こす。呼び出し側が型を判別するif/switchを書き始めたら、閉じた設計が崩れている。

**判断基準**: Protocol準拠の具象実装を差し替えても呼び出し側は壊れないか？

**違反兆候**:
- `as?`で具象型にダウンキャストして分岐する
- Protocol準拠の一部メソッドで空実装やfatalErrorを返す
- 特定の実装でのみ追加の初期化手順が必要

**対処**: Protocolの分割（不要なメソッドを含めない）、事前条件・事後条件の明文化。具象型固有の操作はProtocolに含めず、別のProtocolまたは具象型のメソッドとして提供する。

## ISP: インターフェース分離の原則

> 使わないインターフェースへの依存を強制してはならない。

核心: 不要なメソッドへの依存は、不要な再コンパイルと再デプロイを招く。使用しないメソッドの変更が、使用する側に影響を及ぼすべきではない。

**判断基準**: このProtocolを準拠する型は**全メソッドを意味のある形で**実装できるか？

**違反兆候**:
- Protocol準拠時に空実装やfatalErrorのメソッドがある
- モックが肥大化し、テストで使わないメソッドのスタブが大量にある
- 1つのProtocolに録音・再生・検出など異なる責務のメソッドが混在

**対処**: Protocolの分割、Protocol Composition（`Playable & Seekable`）。小さなProtocolを組み合わせて必要な部分だけ要求する。

## DIP: 依存性逆転の原則

> 上位レベルの方針は下位レベルの詳細に依存すべきではない。どちらも抽象に依存すべきである。

核心: **ソースコードの依存方向を制御**し、上位方針（ドメインルール）を下位詳細（フレームワーク、DB、UI）から守る。Clean Architectureの基盤であり、層の境界を超える依存は必ずProtocolを経由する。

**判断基準**: import文が内側の層から外側の層を参照していないか？

**違反兆候**:
- Domain層がAVFoundation、UIKitをimport
- UseCaseが具象のFileRecordingRepositoryを直接参照
- ViewModelがInfrastructure層の型を直接生成

**対処**: Protocolを「使う側」の層に定義する。DIコンテナ（DependencyContainer）で具象実装を注入する。Protocol定義がInfrastructure層にあるのはDIP違反。

## 原則間の関係

- **SRP違反 → ISP/DIP違反を併発しやすい**: 責任が多いクラスは大きなインターフェースを持ち、不要な依存を引き込む
- **OCPの実現にはDIPが前提**: 抽象に依存しなければ、拡張のために既存コードを変更せざるを得ない
- **LSP違反はOCP違反を引き起こす**: 置換できない型があると、呼び出し側に型チェックの条件分岐が増える
- **ISP違反 → LSP違反を招く**: 大きすぎるProtocolは空実装を生み、置換可能性を損なう

## 設計判断チェックリスト

### 新規クラス/Protocol設計時
- [ ] このクラスの責任は1つのアクターに閉じているか？（SRP）
- [ ] 将来の拡張で既存コードを変更する必要があるか？（OCP）
- [ ] Protocolの全メソッドを意味のある形で実装できるか？（ISP）
- [ ] Protocolは「使う側」の層に定義しているか？（DIP）

### リファクタリング時
- [ ] 具象型チェック（as?）が出現していないか？（LSP）
- [ ] モックの空実装が増えていないか？（ISP）
- [ ] import文が層の境界を越えていないか？（DIP）

### 連携ポイント
- **custom-tdd**: テストが書きにくい → 設計がSOLIDに反している可能性。テスト容易性はSOLID準拠の指標。
- **custom-refactoring**: コードの臭い（Large Class, Feature Envy等）の多くはSOLID違反に起因する。

## Swift固有の適用パターン

詳細は [references/swift-patterns.md](references/swift-patterns.md) を参照:
- SRP: ViewModel分割、Extension活用
- OCP: Protocol + 具象実装、@unknown default
- LSP: Protocol準拠設計、前提条件の明文化
- ISP: Protocol Composition（&構文）、小さなProtocol設計
- DIP: Repository Pattern、DependencyContainer、Protocol定義の配置
